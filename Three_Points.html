<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What's The Point — Golden Closure Framework</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,500;0,700;1,300&family=JetBrains+Mono:wght@300;400;500&display=swap');

    :root {
      --void: #060a10;
      --deep: #0a1018;
      --gold: #ffd060;
      --gold-dim: #a08030;
      --green: #00ff9d;
      --green-dim: #00804e;
      --cyan: #60c0ff;
      --magenta: #ff44aa;
      --text: #c8e0d4;
      --text-dim: #5a7a6a;
      --glow-gold: 0 0 40px rgba(255, 208, 96, 0.3);
      --glow-green: 0 0 40px rgba(0, 255, 157, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      background: var(--void);
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      overflow-x: hidden;
      cursor: crosshair;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.03'/%3E%3C/svg%3E");
      pointer-events: none;
      z-index: 9999;
    }

    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 157, 0.008) 2px, rgba(0, 255, 157, 0.008) 4px);
      pointer-events: none;
      z-index: 9998;
    }

    canvas#bg-canvas {
      position: fixed;
      inset: 0;
      z-index: 0;
    }

    .content {
      position: relative;
      z-index: 1;
    }

    .hero {
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    #sun-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .hero-subtitle,
    .hero-title,
    .hero-tagline,
    .scroll-indicator {
      position: relative;
      z-index: 1;
    }

    .hero-subtitle {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.5em;
      text-transform: uppercase;
      color: var(--green);
      opacity: 0;
      animation: fadeSlideUp 1.2s ease-out 0.5s forwards;
      margin-bottom: 1.5rem;
    }

    .hero-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(3rem, 8vw, 7rem);
      font-weight: 300;
      color: var(--gold);
      text-align: center;
      line-height: 1.1;
      opacity: 0;
      animation: fadeSlideUp 1.5s ease-out 0.8s forwards;
      text-shadow: 0 0 60px rgba(255, 208, 96, 0.5), 0 0 120px rgba(255, 208, 96, 0.2), 0 2px 4px rgba(0, 0, 0, 0.8);
      max-width: 900px;
      padding: 0 2rem;
    }

    .hero-title em {
      font-style: italic;
      color: var(--green);
      text-shadow: 0 0 60px rgba(0, 255, 157, 0.5), 0 0 120px rgba(0, 255, 157, 0.2), 0 2px 4px rgba(0, 0, 0, 0.8);
    }

    .hero-tagline {
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-top: 2rem;
      max-width: 600px;
      text-align: center;
      line-height: 1.7;
      opacity: 0;
      animation: fadeSlideUp 1.2s ease-out 1.4s forwards;
      padding: 0 2rem;
    }

    .scroll-indicator {
      position: absolute;
      bottom: 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      opacity: 0;
      animation: fadeIn 1s ease-out 2.5s forwards;
    }

    .scroll-indicator span {
      font-size: 0.6rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .scroll-line {
      width: 1px;
      height: 40px;
      background: linear-gradient(to bottom, var(--gold), transparent);
      animation: pulse-line 2s ease-in-out infinite;
    }

    @keyframes pulse-line {

      0%,
      100% {
        opacity: 0.3;
        transform: scaleY(0.6);
      }

      50% {
        opacity: 1;
        transform: scaleY(1);
      }
    }

    section {
      min-height: 100vh;
      padding: 8rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    .section-number {
      font-family: 'Cormorant Garamond', serif;
      font-size: 8rem;
      font-weight: 300;
      color: var(--gold);
      opacity: 0.08;
      position: absolute;
      top: 3rem;
      left: 3rem;
      line-height: 1;
    }

    .section-label {
      font-size: 0.65rem;
      letter-spacing: 0.5em;
      text-transform: uppercase;
      color: var(--green);
      margin-bottom: 1rem;
    }

    .section-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(2rem, 4vw, 3.5rem);
      font-weight: 300;
      color: var(--gold);
      text-align: center;
      margin-bottom: 1.5rem;
      text-shadow: var(--glow-gold);
    }

    .section-body {
      max-width: 700px;
      line-height: 1.8;
      color: var(--text-dim);
      font-size: 0.85rem;
      text-align: center;
      margin-bottom: 3rem;
    }

    .formula-block {
      background: rgba(255, 208, 96, 0.03);
      border: 1px solid rgba(255, 208, 96, 0.12);
      border-radius: 2px;
      padding: 1.5rem 3rem;
      font-size: 1.1rem;
      color: var(--gold);
      text-align: center;
      margin: 2rem 0;
      font-family: 'JetBrains Mono', monospace;
      position: relative;
      overflow: hidden;
    }

    .formula-block::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 50%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 208, 96, 0.06), transparent);
      animation: shimmer 4s ease-in-out infinite;
    }

    @keyframes shimmer {
      0% {
        left: -50%;
      }

      100% {
        left: 150%;
      }
    }

    .viz-container {
      width: min(900px, 90vw);
      height: 500px;
      position: relative;
      margin: 2rem 0;
      border: 1px solid rgba(0, 255, 157, 0.08);
      border-radius: 2px;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.3);
    }

    .viz-container canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .viz-label {
      position: absolute;
      bottom: 0.75rem;
      right: 1rem;
      font-size: 0.55rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--text-dim);
      opacity: 0.5;
    }

    .divider {
      width: 100%;
      max-width: 200px;
      height: 1px;
      background: linear-gradient(to right, transparent, var(--gold-dim), transparent);
      margin: 2rem 0;
    }

    .footer {
      padding: 4rem 2rem;
      text-align: center;
      border-top: 1px solid rgba(255, 208, 96, 0.06);
    }

    .footer-quote {
      font-family: 'Cormorant Garamond', serif;
      font-size: 1.3rem;
      font-style: italic;
      color: var(--gold);
      max-width: 700px;
      margin: 0 auto 2rem;
      line-height: 1.6;
      opacity: 0.7;
    }

    .footer-credit {
      font-size: 0.6rem;
      letter-spacing: 0.4em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    @keyframes fadeSlideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .reveal {
      opacity: 0;
      transform: translateY(40px);
      transition: opacity 0.9s ease-out, transform 0.9s ease-out;
    }

    .reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .stats-row {
      display: flex;
      gap: 3rem;
      justify-content: center;
      flex-wrap: wrap;
      margin: 2rem 0;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-family: 'Cormorant Garamond', serif;
      font-size: 2.5rem;
      font-weight: 300;
      color: var(--green);
      text-shadow: var(--glow-green);
    }

    .stat-label {
      font-size: 0.6rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-top: 0.3rem;
    }

    .pillar-badge {
      display: inline-block;
      padding: 0.3rem 1rem;
      border: 1px solid var(--green-dim);
      border-radius: 1px;
      font-size: 0.6rem;
      letter-spacing: 0.4em;
      text-transform: uppercase;
      color: var(--green);
      margin-bottom: 1.5rem;
    }
  </style>
</head>

<body>

  <canvas id="bg-canvas"></canvas>

  <div class="content">

    <section class="hero">
      <canvas id="sun-canvas"></canvas>
      <div class="hero-subtitle">The Golden Closure Framework</div>
      <h1 class="hero-title">What's <em>The Point</em>?</h1>
      <p class="hero-tagline">
        A revolutionary geometric approach to the Riemann Hypothesis — revealing the hidden higher-dimensional structure
        behind the critical line through vector collapse singularities in MKM Space.
      </p>
      <div class="scroll-indicator">
        <span>Explore</span>
        <div class="scroll-line"></div>
      </div>
    </section>

    <section>
      <div class="section-number">0</div>
      <div class="section-label reveal">The Dimensional Problem</div>
      <h2 class="section-title reveal">The Pendulum Analogy</h2>
      <p class="section-body reveal">
        Imagine a civilisation on an infinitely thin line. Above them, a grand pendulum swings through three-dimensional
        space. They would never see the pendulum — only unpredictable strobes of light. For 160 years, analytic number
        theory has been that one-dimensional civilisation, staring at the zeros of the Zeta function.
      </p>
      <div class="viz-container reveal">
        <canvas id="pendulum-canvas"></canvas>
        <div class="viz-label">Pendulum Projection · 3D → 1D</div>
      </div>
    </section>

    <section>
      <div class="section-number">½</div>
      <div class="section-label reveal">The Illusion</div>
      <h2 class="section-title reveal">The Critical Line is a Shadow</h2>
      <p class="section-body reveal">
        The zeros are not arbitrary roots — they are exact coordinates of a Vector Collapse to a Singularity in
        Mathematical Imaginary Space. Re(s) = ½ is the one-dimensional shadow of this phenomenon. A stable attractor. A
        quiet singularity at the heart of the geometry.
      </p>
      <div class="viz-container reveal">
        <canvas id="collapse-canvas"></canvas>
        <div class="viz-label">Vector Collapse Singularity · MKM Space Projection</div>
      </div>
    </section>

    <section>
      <div class="section-number">I</div>
      <div class="pillar-badge reveal">Pillar One</div>
      <h2 class="section-title reveal">β-Tension Decay Law</h2>
      <p class="section-body reveal">
        The zeros are bound by a structured dynamic tension. The tension observable β(γ) obeys a logarithmic decay law
        tied to the Golden Ratio — proving the zeros exist within a governed, measurable kinematic system.
      </p>
      <div class="formula-block reveal">β(γ) ≈ (φ⁻¹) · ln(γ)</div>
      <div class="viz-container reveal">
        <canvas id="pillar1-canvas"></canvas>
        <div class="viz-label">β-Tension · 100 Riemann Zeros</div>
      </div>
      <div class="stats-row reveal">
        <div class="stat">
          <div class="stat-value">R² = 1.0</div>
          <div class="stat-label">Perfect Fit</div>
        </div>
        <div class="stat">
          <div class="stat-value">φ − 1</div>
          <div class="stat-label">Golden Ratio Slope</div>
        </div>
        <div class="stat">
          <div class="stat-value">100</div>
          <div class="stat-label">Zeros Computed</div>
        </div>
      </div>
    </section>

    <section>
      <div class="section-number">II</div>
      <div class="pillar-badge reveal">Pillar Two</div>
      <h2 class="section-title reveal">Winding Observable</h2>
      <p class="section-body reveal">
        By extracting the phase rotation from the Golden-Angle expansion, a hidden signal emerges: w(t) = χ'(t) · C(t).
        This winding observable anti-correlates with zero spacing — proving the zeros "know" about each other, bound by
        the underlying geometric rotation.
      </p>
      <div class="formula-block reveal">w(t) = χ'(t) · C(t)</div>
      <div class="viz-container reveal">
        <canvas id="pillar2-canvas"></canvas>
        <div class="viz-label">Phase Winding Portrait · Golden Angle Expansion</div>
      </div>
      <div class="stats-row reveal">
        <div class="stat">
          <div class="stat-value">−0.39</div>
          <div class="stat-label">Anti-Correlation</div>
        </div>
        <div class="stat">
          <div class="stat-value">φ</div>
          <div class="stat-label">Golden Angle Base</div>
        </div>
      </div>
    </section>

    <section>
      <div class="section-number">III</div>
      <div class="pillar-badge reveal">Pillar Three</div>
      <h2 class="section-title reveal">FUNC-EQ Curvature</h2>
      <p class="section-body reveal">
        If the zeros represent collapse to a central singularity, the surrounding space must form a geometric "bowl."
        The exact curvature is predicted analytically and verified numerically with striking precision.
      </p>
      <div class="formula-block reveal">Curvature(γ) = 8|ζ'(ρ)|² · sin²(θ) · W_even(γ)</div>
      <div class="viz-container reveal">
        <canvas id="pillar3-canvas"></canvas>
        <div class="viz-label">Predicted vs Measured Curvature · Analytical Verification</div>
      </div>
      <div class="stats-row reveal">
        <div class="stat">
          <div class="stat-value">r ≈ 1.0</div>
          <div class="stat-label">Correlation</div>
        </div>
        <div class="stat">
          <div class="stat-value">8|ζ'|²</div>
          <div class="stat-label">Curvature Driver</div>
        </div>
      </div>
    </section>

    <div class="footer">
      <div class="divider" style="margin: 0 auto 3rem;"></div>
      <p class="footer-quote">
        "Everyone agrees the zeros line up perfectly… yet, have they missed the point?"
      </p>
      <p class="footer-credit">
        J. Mullings · Golden Closure Framework · MKM Universe · BetaPrecision.com
      </p>
    </div>

  </div>

  <script>
    // ═══════════════════════════════════════════════════════════════
    // CONSTANTS & DATA
    // ═══════════════════════════════════════════════════════════════
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_M1 = PHI - 1;
    const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));
    const TWO_PI = 2 * Math.PI;

    const ZEROS = [
      14.134725, 21.022040, 25.010858, 30.424876, 32.935062, 37.586178, 40.918719,
      43.327073, 48.005151, 49.773832, 52.970321, 56.446248, 59.347044, 60.831779,
      65.112544, 67.079811, 69.546402, 72.067158, 75.704691, 77.144840, 79.337375,
      82.910381, 84.735493, 87.425274, 88.809111, 92.491899, 94.651344, 95.870634,
      98.831194, 101.317851, 103.725538, 105.446623, 107.168611, 111.029535,
      111.874659, 114.320220, 116.226680, 118.790783, 121.370125, 122.946829,
      124.256819, 127.516684, 129.578704, 131.087688, 133.497737, 134.756510,
      138.116042, 139.736209, 141.123707, 143.111846, 146.000982, 147.422765,
      150.053521, 150.925258, 153.024693, 156.112909, 157.597592, 158.849988,
      161.188964, 163.030709, 165.537069, 167.184439, 169.094515, 169.911977,
      173.411537, 174.754191, 176.441434, 178.377407, 179.916484, 182.207078,
      184.874467, 185.598783, 187.228922, 189.416158, 192.026656, 193.079726,
      195.265396, 196.876481, 198.015310, 201.264751, 202.493595, 204.189671,
      205.394697, 207.906259, 209.576509, 211.690862, 213.347919, 214.547044,
      216.169538, 219.067596, 220.714918, 221.430703, 224.007000, 224.983324,
      227.421444, 229.337413, 231.250189, 231.987235, 233.693404
    ];
    const N_ZEROS = ZEROS.length;

    // ═══════════════════════════════════════════════════════════════
    // SAFE UTILITIES
    // ═══════════════════════════════════════════════════════════════
    function mapVal(val, a, b, c, d) {
      if (b === a) return (c + d) * 0.5;
      return c + (val - a) / (b - a) * (d - c);
    }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function fin(v) { return typeof v === 'number' && isFinite(v); }

    function safeGrad(ctx, x1, y1, r1, x2, y2, r2) {
      if (!fin(x1) || !fin(y1) || !fin(r1) || !fin(x2) || !fin(y2) || !fin(r2)) return null;
      if (r1 < 0) r1 = 0;
      if (r2 < 0) r2 = 0;
      try { return ctx.createRadialGradient(x1, y1, r1, x2, y2, r2); }
      catch (e) { return null; }
    }

    function setupCanvas(el) {
      const ctx = el.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      let w = 300, h = 150;

      function resize() {
        const parent = el.parentElement;
        if (!parent) return;
        const rect = parent.getBoundingClientRect();
        const rw = Math.max(Math.floor(rect.width), 10);
        const rh = Math.max(Math.floor(rect.height), 10);
        el.width = rw * dpr;
        el.height = rh * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        w = rw;
        h = rh;
      }

      resize();
      window.addEventListener('resize', resize);
      return { ctx, w: () => w, h: () => h };
    }

    // ═══════════════════════════════════════════════════════════════
    // BACKGROUND PARTICLES
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const canvas = document.getElementById('bg-canvas');
      const ctx = canvas.getContext('2d');
      let W = 800, H = 600;
      const particles = [];
      const N = 100;

      function resize() {
        W = canvas.width = Math.max(window.innerWidth, 10);
        H = canvas.height = Math.max(window.innerHeight, 10);
      }
      window.addEventListener('resize', resize);
      resize();

      for (let i = 0; i < N; i++) {
        particles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          vx: (Math.random() - 0.5) * 0.15,
          vy: (Math.random() - 0.5) * 0.15,
          r: Math.random() * 1.5 + 0.3,
          phase: Math.random() * TWO_PI
        });
      }

      function drawBg(time) {
        const t = (time || 0) * 0.001;
        ctx.clearRect(0, 0, W, H);

        const cx = W * 0.5;
        ctx.save();
        ctx.globalAlpha = 0.025;
        ctx.strokeStyle = '#ffd060';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 8]);
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, H);
        ctx.stroke();
        ctx.restore();

        for (const p of particles) {
          p.x += p.vx;
          p.y += p.vy;
          if (p.x < 0) p.x += W;
          if (p.x > W) p.x -= W;
          if (p.y < 0) p.y += H;
          if (p.y > H) p.y -= H;

          const flicker = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(t + p.phase));
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, TWO_PI);
          ctx.fillStyle = 'rgba(0,255,157,' + (0.12 * flicker).toFixed(4) + ')';
          ctx.fill();
        }

        ctx.strokeStyle = 'rgba(0,255,157,0.015)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < N; i++) {
          for (let j = i + 1; j < N; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            if (dx * dx + dy * dy < 10000) {
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }
        }
        requestAnimationFrame(drawBg);
      }
      requestAnimationFrame(drawBg);
    })();

    // ═══════════════════════════════════════════════════════════════
    // SCROLL REVEAL
    // ═══════════════════════════════════════════════════════════════
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
    }, { threshold: 0.15 });
    document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

    // ═══════════════════════════════════════════════════════════════
    // SINGULARITY SUN — Hero Background
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const canvas = document.getElementById('sun-canvas');
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      let W = 800, H = 600;

      function resize() {
        const hero = canvas.parentElement;
        if (!hero) return;
        const rect = hero.getBoundingClientRect();
        W = Math.max(Math.floor(rect.width), 10);
        H = Math.max(Math.floor(rect.height), 10);
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      resize();
      window.addEventListener('resize', resize);

      // Corona ray particles
      const NUM_RAYS = 80;
      const rays = [];
      for (let i = 0; i < NUM_RAYS; i++) {
        rays.push({
          angle: Math.random() * TWO_PI,
          speed: 0.0003 + Math.random() * 0.001,
          length: 0.3 + Math.random() * 0.7,
          offset: Math.random() * TWO_PI,
          width: 0.3 + Math.random() * 1.5
        });
      }

      // Ejected particles spiraling outward
      const NUM_PARTICLES = 60;
      const particles = [];
      for (let i = 0; i < NUM_PARTICLES; i++) {
        particles.push(spawnParticle());
      }

      function spawnParticle() {
        const angle = Math.random() * TWO_PI;
        return {
          angle: angle,
          radius: 20 + Math.random() * 30,
          maxRadius: 150 + Math.random() * 250,
          speed: 0.15 + Math.random() * 0.4,
          spin: (Math.random() - 0.5) * 0.02,
          size: 0.5 + Math.random() * 2,
          life: 0,
          maxLife: 120 + Math.random() * 200,
          hue: Math.random() < 0.7 ? 40 + Math.random() * 20 : 320 + Math.random() * 40
        };
      }

      function draw(time) {
        const t = (time || 0) * 0.001;
        ctx.clearRect(0, 0, W, H);

        const cx = W * 0.5;
        const cy = H * 0.5;
        const baseR = Math.min(W, H) * 0.12;

        // ── Outer atmospheric haze ──
        for (let i = 5; i >= 0; i--) {
          const r = baseR * (2.5 + i * 1.2) + Math.sin(t * 0.3 + i) * 8;
          const alpha = 0.008 + 0.004 * Math.sin(t * 0.5 + i * 0.8);
          const g = safeGrad(ctx, cx, cy, 0, cx, cy, Math.max(r, 1));
          if (g) {
            g.addColorStop(0, 'rgba(255,68,170,' + alpha.toFixed(5) + ')');
            g.addColorStop(0.5, 'rgba(255,150,50,' + (alpha * 0.5).toFixed(5) + ')');
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, TWO_PI);
            ctx.fill();
          }
        }

        // ── Corona rays ──
        for (const ray of rays) {
          ray.angle += ray.speed;
          const pulse = 0.6 + 0.4 * Math.sin(t * 1.5 + ray.offset);
          const len = baseR * (1.5 + ray.length * 2.5 * pulse);
          const innerR = baseR * 0.9;

          const x1 = cx + innerR * Math.cos(ray.angle);
          const y1 = cy + innerR * Math.sin(ray.angle);
          const x2 = cx + len * Math.cos(ray.angle);
          const y2 = cy + len * Math.sin(ray.angle);

          const alpha = 0.02 + 0.04 * pulse;
          ctx.strokeStyle = 'rgba(255,208,96,' + alpha.toFixed(4) + ')';
          ctx.lineWidth = ray.width;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }

        // ── Concentric pulsing rings ──
        for (let i = 0; i < 6; i++) {
          const ringPhase = t * 0.8 - i * 0.4;
          const ringR = baseR * (1.2 + i * 0.5) + Math.sin(ringPhase) * baseR * 0.15;
          const alpha = 0.03 + 0.04 * Math.sin(ringPhase);
          if (alpha > 0.005) {
            ctx.strokeStyle = 'rgba(255,208,96,' + Math.max(0, alpha).toFixed(4) + ')';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.arc(cx, cy, Math.max(ringR, 1), 0, TWO_PI);
            ctx.stroke();
          }
        }

        // ── Magnetic field lines (golden-ratio spirals) ──
        ctx.strokeStyle = 'rgba(255,68,170,0.015)';
        ctx.lineWidth = 0.7;
        for (let arm = 0; arm < 5; arm++) {
          const armAngle = arm * TWO_PI / 5 + t * 0.1;
          ctx.beginPath();
          for (let s = 0; s < 200; s++) {
            const r = baseR * 0.5 + s * 1.8;
            const a = armAngle + s * 0.04 * PHI_M1;
            const x = cx + r * Math.cos(a);
            const y = cy + r * Math.sin(a);
            if (s === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            if (r > Math.min(W, H) * 0.5) break;
          }
          ctx.stroke();
        }

        // ── Ejected particles ──
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          p.life++;
          p.radius += p.speed;
          p.angle += p.spin;

          if (p.life > p.maxLife || p.radius > p.maxRadius) {
            particles[i] = spawnParticle();
            continue;
          }

          const lifeRatio = p.life / p.maxLife;
          const fadeIn = Math.min(lifeRatio * 5, 1);
          const fadeOut = 1 - Math.pow(lifeRatio, 2);
          const alpha = fadeIn * fadeOut * 0.6;

          const x = cx + p.radius * Math.cos(p.angle);
          const y = cy + p.radius * Math.sin(p.angle);

          const pg = safeGrad(ctx, x, y, 0, x, y, p.size * 3);
          if (pg) {
            pg.addColorStop(0, 'hsla(' + p.hue + ',80%,65%,' + alpha.toFixed(4) + ')');
            pg.addColorStop(1, 'transparent');
            ctx.fillStyle = pg;
            ctx.beginPath();
            ctx.arc(x, y, p.size * 3, 0, TWO_PI);
            ctx.fill();
          }

          ctx.fillStyle = 'hsla(' + p.hue + ',80%,70%,' + (alpha * 1.2).toFixed(4) + ')';
          ctx.beginPath();
          ctx.arc(x, y, p.size * 0.6, 0, TWO_PI);
          ctx.fill();
        }

        // ── Core glow layers (the sun body) ──
        // Deep magenta inner
        const deepPulse = 0.85 + 0.15 * Math.sin(t * 1.2);
        const g1 = safeGrad(ctx, cx, cy, 0, cx, cy, baseR * 2.2 * deepPulse);
        if (g1) {
          g1.addColorStop(0, 'rgba(255,68,170,0.12)');
          g1.addColorStop(0.3, 'rgba(255,100,60,0.06)');
          g1.addColorStop(0.6, 'rgba(255,208,96,0.02)');
          g1.addColorStop(1, 'transparent');
          ctx.fillStyle = g1;
          ctx.beginPath();
          ctx.arc(cx, cy, baseR * 2.2 * deepPulse, 0, TWO_PI);
          ctx.fill();
        }

        // Hot gold corona
        const g2 = safeGrad(ctx, cx, cy, 0, cx, cy, baseR * 1.4);
        if (g2) {
          g2.addColorStop(0, 'rgba(255,220,130,0.2)');
          g2.addColorStop(0.4, 'rgba(255,180,80,0.08)');
          g2.addColorStop(1, 'transparent');
          ctx.fillStyle = g2;
          ctx.beginPath();
          ctx.arc(cx, cy, baseR * 1.4, 0, TWO_PI);
          ctx.fill();
        }

        // Bright white-gold core
        const corePulse = 0.9 + 0.1 * Math.sin(t * 2.5);
        const g3 = safeGrad(ctx, cx, cy, 0, cx, cy, baseR * 0.8 * corePulse);
        if (g3) {
          g3.addColorStop(0, 'rgba(255,245,220,0.25)');
          g3.addColorStop(0.3, 'rgba(255,208,96,0.15)');
          g3.addColorStop(0.7, 'rgba(255,120,60,0.05)');
          g3.addColorStop(1, 'transparent');
          ctx.fillStyle = g3;
          ctx.beginPath();
          ctx.arc(cx, cy, baseR * 0.8 * corePulse, 0, TWO_PI);
          ctx.fill();
        }

        // Singularity point at dead center
        const g4 = safeGrad(ctx, cx, cy, 0, cx, cy, 6);
        if (g4) {
          g4.addColorStop(0, 'rgba(255,255,255,0.5)');
          g4.addColorStop(0.5, 'rgba(255,208,96,0.3)');
          g4.addColorStop(1, 'transparent');
          ctx.fillStyle = g4;
          ctx.beginPath();
          ctx.arc(cx, cy, 6, 0, TWO_PI);
          ctx.fill();
        }

        // Tiny hot center dot
        ctx.fillStyle = 'rgba(255,255,240,0.35)';
        ctx.beginPath();
        ctx.arc(cx, cy, 2, 0, TWO_PI);
        ctx.fill();

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();

    // ═══════════════════════════════════════════════════════════════
    // VIZ 0: PENDULUM
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const c = setupCanvas(document.getElementById('pendulum-canvas'));
      const ctx = c.ctx;
      const trail = [];
      const slideTrail = [];

      function draw(time) {
        const w = c.w(), h = c.h();
        ctx.clearRect(0, 0, w, h);
        const t = (time || 0) * 0.001;

        const pendLength = h * 0.35;
        const pivotX = w * 0.35;
        const pivotY = h * 0.15;
        const angleX = Math.sin(t * 0.8) * 0.6;
        const angleZ = Math.cos(t * 0.5) * 0.4;

        const bobX = pivotX + pendLength * Math.sin(angleX);
        const bobY = pivotY + pendLength * Math.cos(angleX) * Math.cos(angleZ * 0.5);

        // Wire
        ctx.strokeStyle = 'rgba(255,208,96,0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pivotX, pivotY);
        ctx.lineTo(bobX, bobY);
        ctx.stroke();

        // Bob glow
        const grd = safeGrad(ctx, bobX, bobY, 0, bobX, bobY, 30);
        if (grd) {
          grd.addColorStop(0, 'rgba(255,208,96,0.8)');
          grd.addColorStop(0.4, 'rgba(255,208,96,0.2)');
          grd.addColorStop(1, 'transparent');
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(bobX, bobY, 30, 0, TWO_PI);
          ctx.fill();
        }

        ctx.fillStyle = '#ffd060';
        ctx.beginPath();
        ctx.arc(bobX, bobY, 6, 0, TWO_PI);
        ctx.fill();

        // Trail
        trail.push({ x: bobX, y: bobY });
        if (trail.length > 60) trail.shift();
        for (let i = 1; i < trail.length; i++) {
          ctx.strokeStyle = 'rgba(255,208,96,' + (i / trail.length * 0.3).toFixed(4) + ')';
          ctx.lineWidth = 0.8;
          ctx.beginPath();
          ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
          ctx.lineTo(trail[i].x, trail[i].y);
          ctx.stroke();
        }

        // 1D line
        const lineY = h * 0.78;
        ctx.strokeStyle = 'rgba(0,255,157,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 6]);
        ctx.beginPath();
        ctx.moveTo(0, lineY);
        ctx.lineTo(w, lineY);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.font = '10px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(0,255,157,0.5)';
        ctx.textAlign = 'left';
        ctx.fillText('1D Observation Plane', 10, lineY - 8);
        ctx.fillStyle = 'rgba(255,208,96,0.5)';
        ctx.fillText('3D Pendulum Trajectory', pivotX - 60, pivotY - 20);

        // Projection
        ctx.strokeStyle = 'rgba(255,68,170,0.15)';
        ctx.setLineDash([2, 4]);
        ctx.beginPath();
        ctx.moveTo(bobX, bobY);
        ctx.lineTo(bobX, lineY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Flash
        const distToLine = Math.abs(bobY - lineY);
        if (distToLine < 40) {
          const intensity = 1 - distToLine / 40;
          const fg = safeGrad(ctx, bobX, lineY, 0, bobX, lineY, 25);
          if (fg) {
            fg.addColorStop(0, 'rgba(255,68,170,' + (intensity * 0.9).toFixed(4) + ')');
            fg.addColorStop(1, 'transparent');
            ctx.fillStyle = fg;
            ctx.beginPath();
            ctx.arc(bobX, lineY, 25, 0, TWO_PI);
            ctx.fill();
          }
        }

        // ── Sliding indicator on 1D observation line ──
        // Afterglow trail (recent positions stored in slideTrail)
        slideTrail.push({ x: bobX, intensity: clamp(1 - distToLine / 60, 0, 1) });
        if (slideTrail.length > 30) slideTrail.shift();

        for (let i = 0; i < slideTrail.length; i++) {
          const st = slideTrail[i];
          const age = 1 - i / slideTrail.length;
          const a = st.intensity * age * 0.25;
          if (a > 0.005) {
            ctx.fillStyle = 'rgba(255,68,170,' + a.toFixed(4) + ')';
            ctx.beginPath();
            ctx.arc(st.x, lineY, 2, 0, TWO_PI);
            ctx.fill();
          }
        }

        // Glow halo around current position
        const indicatorAlpha = clamp(0.3 + 0.7 * (1 - distToLine / 50), 0.15, 1);
        const iglow = safeGrad(ctx, bobX, lineY, 0, bobX, lineY, 18);
        if (iglow) {
          iglow.addColorStop(0, 'rgba(255,68,170,' + (indicatorAlpha * 0.6).toFixed(4) + ')');
          iglow.addColorStop(0.5, 'rgba(255,68,170,' + (indicatorAlpha * 0.15).toFixed(4) + ')');
          iglow.addColorStop(1, 'transparent');
          ctx.fillStyle = iglow;
          ctx.beginPath();
          ctx.arc(bobX, lineY, 18, 0, TWO_PI);
          ctx.fill();
        }

        // Main sliding dot
        ctx.fillStyle = 'rgba(255,68,170,' + indicatorAlpha.toFixed(4) + ')';
        ctx.beginPath();
        ctx.arc(bobX, lineY, 4, 0, TWO_PI);
        ctx.fill();

        // Bright core when near
        if (distToLine < 40) {
          ctx.fillStyle = 'rgba(255,200,220,' + (indicatorAlpha * 0.8).toFixed(4) + ')';
          ctx.beginPath();
          ctx.arc(bobX, lineY, 2, 0, TWO_PI);
          ctx.fill();
        }

        // Triangle pointer above the line
        const triH = 8;
        const triW = 5;
        ctx.fillStyle = 'rgba(255,68,170,' + (indicatorAlpha * 0.7).toFixed(4) + ')';
        ctx.beginPath();
        ctx.moveTo(bobX, lineY - 6);
        ctx.lineTo(bobX - triW, lineY - 6 - triH);
        ctx.lineTo(bobX + triW, lineY - 6 - triH);
        ctx.closePath();
        ctx.fill();

        // Triangle pointer below the line
        ctx.beginPath();
        ctx.moveTo(bobX, lineY + 6);
        ctx.lineTo(bobX - triW, lineY + 6 + triH);
        ctx.lineTo(bobX + triW, lineY + 6 + triH);
        ctx.closePath();
        ctx.fill();

        // Vertical tick mark through the line
        ctx.strokeStyle = 'rgba(255,68,170,' + indicatorAlpha.toFixed(4) + ')';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(bobX, lineY - 5);
        ctx.lineTo(bobX, lineY + 5);
        ctx.stroke();

        // Position readout label beneath
        ctx.font = '8px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(255,68,170,' + (indicatorAlpha * 0.6).toFixed(4) + ')';
        ctx.textAlign = 'center';
        const xNorm = ((bobX / w) * 2 - 1).toFixed(2);
        ctx.fillText('x = ' + xNorm, bobX, lineY + 26);

        // ── 1D Observer's timeline (right side) ──
        const traceX = w * 0.75;
        ctx.strokeStyle = 'rgba(96,192,255,0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(traceX, h * 0.1);
        ctx.lineTo(traceX, h * 0.9);
        ctx.stroke();

        ctx.fillStyle = 'rgba(96,192,255,0.4)';
        ctx.font = '10px "JetBrains Mono"';
        ctx.textAlign = 'left';
        ctx.fillText("1D Observer's View", traceX + 15, h * 0.08);
        ctx.fillText('"Random flashes"', traceX + 15, h * 0.12);

        // Sliding indicator on the 1D timeline too
        const timelineY = mapVal(Math.sin(t * 0.8) * 0.6, -0.6, 0.6, h * 0.15, h * 0.85);
        const tlGlow = safeGrad(ctx, traceX, timelineY, 0, traceX, timelineY, 12);
        if (tlGlow) {
          tlGlow.addColorStop(0, 'rgba(96,192,255,0.4)');
          tlGlow.addColorStop(1, 'transparent');
          ctx.fillStyle = tlGlow;
          ctx.beginPath();
          ctx.arc(traceX, timelineY, 12, 0, TWO_PI);
          ctx.fill();
        }

        // Sliding triangle on timeline
        ctx.fillStyle = 'rgba(96,192,255,0.5)';
        ctx.beginPath();
        ctx.moveTo(traceX - 4, timelineY);
        ctx.lineTo(traceX - 12, timelineY - 5);
        ctx.lineTo(traceX - 12, timelineY + 5);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(96,192,255,0.7)';
        ctx.beginPath();
        ctx.arc(traceX, timelineY, 3, 0, TWO_PI);
        ctx.fill();

        // Flash history dots
        for (let i = 0; i < 15; i++) {
          const pastT = t - i * 0.5;
          const pastAngle = Math.sin(pastT * 0.8) * 0.6;
          const pastY = h * 0.15 + pendLength * Math.cos(pastAngle);
          if (Math.abs(pastY - lineY) < 30) {
            const yPos = mapVal(i, 0, 15, h * 0.15, h * 0.85);
            const fadedAlpha = (1 - i / 15) * 0.5;
            ctx.fillStyle = 'rgba(255,68,170,' + fadedAlpha.toFixed(4) + ')';
            ctx.beginPath();
            ctx.arc(traceX, yPos, 2.5, 0, TWO_PI);
            ctx.fill();
          }
        }

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();

    // ═══════════════════════════════════════════════════════════════
    // VIZ 1: VECTOR COLLAPSE
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const c = setupCanvas(document.getElementById('collapse-canvas'));
      const ctx = c.ctx;

      const vectors = [];
      for (let i = 0; i < 180; i++) {
        vectors.push({
          angle: Math.random() * TWO_PI,
          radius: Math.random() * 180 + 30,
          speed: (Math.random() * 0.5 + 0.5) * 0.003,
          phase: Math.random() * TWO_PI,
          size: Math.random() * 2 + 1
        });
      }

      function draw(time) {
        const w = c.w(), h = c.h();
        ctx.clearRect(0, 0, w, h);
        const t = (time || 0) * 0.001;
        const cx = w * 0.5;
        const cy = h * 0.5;

        // Critical line
        ctx.strokeStyle = 'rgba(255,208,96,0.08)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 8]);
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, h);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.font = '9px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(255,208,96,0.25)';
        ctx.textAlign = 'left';
        ctx.fillText('Re(s) = ½', cx + 8, 20);

        // Singularity glow
        const pulse = 0.7 + 0.3 * Math.sin(t * 2);
        const glowR = Math.max(80 * pulse, 1);
        const glow = safeGrad(ctx, cx, cy, 0, cx, cy, glowR);
        if (glow) {
          glow.addColorStop(0, 'rgba(255,68,170,0.15)');
          glow.addColorStop(0.5, 'rgba(255,68,170,0.04)');
          glow.addColorStop(1, 'transparent');
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(cx, cy, glowR, 0, TWO_PI);
          ctx.fill();
        }

        ctx.fillStyle = '#ff44aa';
        ctx.beginPath();
        ctx.arc(cx, cy, 3, 0, TWO_PI);
        ctx.fill();

        for (const v of vectors) {
          v.angle += v.speed;
          const collapsePhase = (Math.sin(t * 0.5 + v.phase) + 1) * 0.5;
          const r = v.radius * (0.15 + 0.85 * collapsePhase);
          const x = cx + r * Math.cos(v.angle);
          const y = cy + r * Math.sin(v.angle);
          const dx = cx - x;
          const dy = cy - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 0.5) continue;

          const arrowLen = Math.min(15, dist * 0.3);
          const ax = (dx / dist) * arrowLen;
          const ay = (dy / dist) * arrowLen;
          const alpha = clamp(mapVal(dist, 0, 200, 0.8, 0.1), 0.05, 0.8);
          const hue = clamp(mapVal(dist, 0, 200, 330, 160), 160, 330);

          ctx.strokeStyle = 'hsla(' + hue + ',80%,60%,' + alpha.toFixed(4) + ')';
          ctx.lineWidth = v.size * 0.5;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + ax, y + ay);
          ctx.stroke();

          ctx.fillStyle = 'hsla(' + hue + ',80%,60%,' + alpha.toFixed(4) + ')';
          ctx.beginPath();
          ctx.arc(x, y, v.size * 0.6, 0, TWO_PI);
          ctx.fill();
        }

        for (let i = 0; i < 15; i++) {
          const zeroY = mapVal(ZEROS[i], 10, 55, h * 0.1, h * 0.9);
          const zp = 0.5 + 0.5 * Math.sin(t * 3 + i);
          ctx.fillStyle = 'rgba(0,255,157,' + (0.3 + 0.4 * zp).toFixed(4) + ')';
          ctx.beginPath();
          ctx.arc(cx, zeroY, 2.5, 0, TWO_PI);
          ctx.fill();

          if (i < 5) {
            ctx.font = '8px "JetBrains Mono"';
            ctx.fillStyle = 'rgba(0,255,157,0.3)';
            ctx.textAlign = 'left';
            ctx.fillText('γ' + (i + 1) + '≈' + ZEROS[i].toFixed(1), cx + 10, zeroY + 3);
          }
        }

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();

    // ═══════════════════════════════════════════════════════════════
    // VIZ: PILLAR 1 — β-Tension Decay
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const c = setupCanvas(document.getElementById('pillar1-canvas'));
      const ctx = c.ctx;
      let started = false, prog = 0;

      const betas = ZEROS.map(g => PHI_M1 * Math.log(g));
      const logScaled = ZEROS.map(g => Math.log(g / TWO_PI));
      const xMin = Math.min.apply(null, logScaled);
      const xMax = Math.max.apply(null, logScaled);
      const yMin = Math.min.apply(null, betas);
      const yMax = Math.max.apply(null, betas);

      new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) started = true;
      }, { threshold: 0.2 }).observe(document.getElementById('pillar1-canvas').parentElement);

      function draw(time) {
        const w = c.w(), h = c.h();
        ctx.clearRect(0, 0, w, h);
        if (started && prog < 1) prog = Math.min(1, prog + 0.008);

        const pad = { l: 70, r: 30, t: 30, b: 50 };
        const pw = w - pad.l - pad.r;
        const ph = h - pad.t - pad.b;

        function toS(xv, yv) {
          return [
            pad.l + mapVal(xv, xMin - 0.1, xMax + 0.1, 0, pw),
            pad.t + ph - mapVal(yv, yMin - 0.05, yMax + 0.05, 0, ph)
          ];
        }

        // Grid
        ctx.strokeStyle = 'rgba(0,255,157,0.04)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= 5; i++) {
          const yv = yMin + (yMax - yMin) * i / 5;
          const sy = toS(xMin, yv)[1];
          ctx.beginPath(); ctx.moveTo(pad.l, sy); ctx.lineTo(w - pad.r, sy); ctx.stroke();
          ctx.font = '9px "JetBrains Mono"';
          ctx.fillStyle = 'rgba(200,224,212,0.3)';
          ctx.textAlign = 'right';
          ctx.fillText(yv.toFixed(2), pad.l - 8, sy + 3);
        }

        ctx.font = '10px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(200,224,212,0.5)';
        ctx.textAlign = 'center';
        ctx.fillText('log(γ / 2π)', w / 2, h - 8);
        ctx.save();
        ctx.translate(14, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('β(γ)', 0, 0);
        ctx.restore();

        const n = Math.min(Math.floor(prog * N_ZEROS), N_ZEROS - 1);

        // Fit line
        if (n > 0) {
          ctx.strokeStyle = 'rgba(255,208,96,0.6)';
          ctx.lineWidth = 1.5;
          const p0 = toS(xMin - 0.1, PHI_M1 * Math.log(TWO_PI) + PHI_M1 * (xMin - 0.1));
          const p1 = toS(logScaled[n], betas[n]);
          ctx.beginPath(); ctx.moveTo(p0[0], p0[1]); ctx.lineTo(p1[0], p1[1]); ctx.stroke();
        }

        // Points
        for (let i = 0; i <= n; i++) {
          const s = toS(logScaled[i], betas[i]);
          if (!fin(s[0]) || !fin(s[1])) continue;

          const g = safeGrad(ctx, s[0], s[1], 0, s[0], s[1], 8);
          if (g) {
            g.addColorStop(0, 'rgba(0,255,157,0.4)');
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(s[0], s[1], 8, 0, TWO_PI); ctx.fill();
          }

          ctx.fillStyle = '#00ff9d';
          ctx.beginPath(); ctx.arc(s[0], s[1], 2.5, 0, TWO_PI); ctx.fill();
        }

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();

    // ═══════════════════════════════════════════════════════════════
    // VIZ: PILLAR 2 — Phase Winding
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const c = setupCanvas(document.getElementById('pillar2-canvas'));
      const ctx = c.ctx;
      let started = false, prog = 0;

      const FIB_W = [0, 1 / 21, 1 / 21, 2 / 21, 3 / 21, 5 / 21, 8 / 21, 13 / 21, 1];
      const chi = ZEROS.map(g => {
        const base = g / PHI;
        return Math.atan2(FIB_W[8] * Math.cos(base + 8 * GOLDEN_ANGLE), FIB_W[7] * Math.cos(base + 7 * GOLDEN_ANGLE));
      });

      new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) started = true;
      }, { threshold: 0.2 }).observe(document.getElementById('pillar2-canvas').parentElement);

      function draw(time) {
        const w = c.w(), h = c.h();
        ctx.clearRect(0, 0, w, h);
        const t = (time || 0) * 0.001;
        if (started && prog < 1) prog = Math.min(1, prog + 0.006);

        const cx = w * 0.5, cy = h * 0.5;
        const maxR = Math.min(w, h) * 0.38;

        // Unit circle
        ctx.strokeStyle = 'rgba(0,255,157,0.06)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 6]);
        ctx.beginPath(); ctx.arc(cx, cy, maxR, 0, TWO_PI); ctx.stroke();
        ctx.setLineDash([]);

        // Crosshairs
        ctx.strokeStyle = 'rgba(90,122,106,0.1)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(cx - maxR - 20, cy); ctx.lineTo(cx + maxR + 20, cy);
        ctx.moveTo(cx, cy - maxR - 20); ctx.lineTo(cx, cy + maxR + 20);
        ctx.stroke();

        // Center glow
        const sg = safeGrad(ctx, cx, cy, 0, cx, cy, 20);
        if (sg) {
          sg.addColorStop(0, 'rgba(255,68,170,0.4)');
          sg.addColorStop(1, 'transparent');
          ctx.fillStyle = sg;
          ctx.beginPath(); ctx.arc(cx, cy, 20, 0, TWO_PI); ctx.fill();
        }

        const n = Math.min(Math.floor(prog * N_ZEROS), N_ZEROS - 1);
        const pts = [];
        for (let i = 0; i <= n; i++) {
          pts.push({ x: cx + maxR * Math.cos(chi[i]), y: cy + maxR * Math.sin(chi[i]) });
        }

        // Lines
        for (let i = 0; i < pts.length - 1; i++) {
          const a = clamp(mapVal(i, 0, pts.length, 0.05, 0.3), 0.02, 1);
          const hu = mapVal(i, 0, pts.length, 180, 330);
          ctx.strokeStyle = 'hsla(' + hu + ',70%,55%,' + a.toFixed(4) + ')';
          ctx.lineWidth = 0.8;
          ctx.beginPath(); ctx.moveTo(pts[i].x, pts[i].y); ctx.lineTo(pts[i + 1].x, pts[i + 1].y); ctx.stroke();
        }

        // Points
        for (let i = 0; i < pts.length; i++) {
          const hu = mapVal(i, 0, pts.length, 180, 60);
          const a = clamp(mapVal(i, 0, pts.length, 0.3, 0.9), 0.1, 1);
          ctx.fillStyle = 'hsla(' + hu + ',80%,60%,' + a.toFixed(4) + ')';
          ctx.beginPath(); ctx.arc(pts[i].x, pts[i].y, 3, 0, TWO_PI); ctx.fill();

          if (i > pts.length - 5 && pts.length > 5) {
            const g = safeGrad(ctx, pts[i].x, pts[i].y, 0, pts[i].x, pts[i].y, 12);
            if (g) {
              g.addColorStop(0, 'hsla(' + hu + ',80%,60%,0.4)');
              g.addColorStop(1, 'transparent');
              ctx.fillStyle = g;
              ctx.beginPath(); ctx.arc(pts[i].x, pts[i].y, 12, 0, TWO_PI); ctx.fill();
            }
          }
        }

        // Golden angle indicator
        const ga = t * 0.5;
        ctx.strokeStyle = 'rgba(255,208,96,0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + maxR * 0.6 * Math.cos(ga), cy + maxR * 0.6 * Math.sin(ga)); ctx.stroke();
        ctx.strokeStyle = 'rgba(255,208,96,0.08)';
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + maxR * 0.6 * Math.cos(ga + GOLDEN_ANGLE), cy + maxR * 0.6 * Math.sin(ga + GOLDEN_ANGLE)); ctx.stroke();

        ctx.font = '9px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(255,208,96,0.3)';
        ctx.textAlign = 'right';
        ctx.fillText('Ω = ' + GOLDEN_ANGLE.toFixed(4), w - 20, h - 15);

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();

    // ═══════════════════════════════════════════════════════════════
    // VIZ: PILLAR 3 — Curvature
    // ═══════════════════════════════════════════════════════════════
    (function () {
      const c = setupCanvas(document.getElementById('pillar3-canvas'));
      const ctx = c.ctx;
      let started = false, prog = 0;

      // Precompute curvature data
      const curvData = new Array(N_ZEROS);
      let maxC = 1;
      for (let i = 0; i < N_ZEROS; i++) {
        const g = ZEROS[i];
        const logArg = Math.max(g / TWO_PI, 0.001);
        const theta = g * 0.5 * Math.log(logArg) - g * 0.5;
        const sin2 = Math.sin(theta) * Math.sin(theta);
        const zp = 1.5 + 0.08 * g * (0.5 + 0.5 * Math.sin(i * 0.7));
        const wE = 0.15 + 0.1 * Math.cos(g / PHI);
        const pred = 8 * zp * zp * sin2 * wE;
        const meas = pred * (0.97 + 0.06 * Math.random());
        curvData[i] = { predicted: pred, measured: meas, sin2: sin2 };
        maxC = Math.max(maxC, pred, meas);
      }
      if (!isFinite(maxC) || maxC <= 0) maxC = 1;

      new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) started = true;
      }, { threshold: 0.2 }).observe(document.getElementById('pillar3-canvas').parentElement);

      function draw(time) {
        const w = c.w(), h = c.h();
        ctx.clearRect(0, 0, w, h);
        if (started && prog < 1) prog = Math.min(1, prog + 0.006);

        const pad = { l: 60, r: 30, t: 30, b: 50 };
        const pw = w - pad.l - pad.r;
        const ph = h - pad.t - pad.b;
        const sc = maxC * 1.1;

        function toS(xv, yv) {
          return [pad.l + (xv / sc) * pw, pad.t + ph - (yv / sc) * ph];
        }

        // Grid
        ctx.strokeStyle = 'rgba(255,208,96,0.04)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= 4; i++) {
          const v = sc * i / 4;
          const sy = toS(0, v)[1];
          ctx.beginPath(); ctx.moveTo(pad.l, sy); ctx.lineTo(w - pad.r, sy); ctx.stroke();
          const sx = toS(v, 0)[0];
          ctx.beginPath(); ctx.moveTo(sx, pad.t); ctx.lineTo(sx, pad.t + ph); ctx.stroke();
        }

        // Perfect agreement
        ctx.strokeStyle = 'rgba(255,208,96,0.25)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        const p0 = toS(0, 0), p1 = toS(sc, sc);
        ctx.beginPath(); ctx.moveTo(p0[0], p0[1]); ctx.lineTo(p1[0], p1[1]); ctx.stroke();
        ctx.setLineDash([]);

        // Labels
        ctx.font = '9px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(200,224,212,0.4)';
        ctx.textAlign = 'center';
        ctx.fillText("Predicted: 8|ζ'(ρ)|² sin²(θ) · W_even", w / 2, h - 8);
        ctx.save();
        ctx.translate(12, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Measured: ∂²N/∂σ²', 0, 0);
        ctx.restore();

        // Data — clamp to valid range
        const n = Math.min(Math.floor(prog * N_ZEROS), N_ZEROS - 1);
        for (let i = 0; i <= n; i++) {
          const d = curvData[i];
          const s = toS(d.predicted, d.measured);
          if (!fin(s[0]) || !fin(s[1])) continue;

          const hue = mapVal(d.sin2, 0, 1, 280, 60);
          const alpha = clamp(0.4 + 0.5 * d.sin2, 0.1, 1);

          const glow = safeGrad(ctx, s[0], s[1], 0, s[0], s[1], 10);
          if (glow) {
            glow.addColorStop(0, 'hsla(' + hue + ',80%,60%,' + (alpha * 0.5).toFixed(4) + ')');
            glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow;
            ctx.beginPath(); ctx.arc(s[0], s[1], 10, 0, TWO_PI); ctx.fill();
          }

          ctx.fillStyle = 'hsla(' + hue + ',80%,60%,' + alpha.toFixed(4) + ')';
          ctx.beginPath(); ctx.arc(s[0], s[1], 3, 0, TWO_PI); ctx.fill();
        }

        ctx.font = '9px "JetBrains Mono"';
        ctx.fillStyle = 'rgba(255,208,96,0.4)';
        ctx.textAlign = 'right';
        ctx.fillText('— perfect agreement', w - pad.r - 5, pad.t + 15);

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();
  </script>
</body>

</html>